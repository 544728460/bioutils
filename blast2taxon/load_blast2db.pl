#!/usr/bin/perl

# {{{ POD
=head1 NAME

    load_blast2db.pl - Load part of BLAST XML report and taxonomy informatin
                       into an SQLite3 database.

=head1 SYNOPSIS

=head1 DESCRIPTION

	    In the current BLAST distributuon, e.g., BLAST+ 2.2.31, the general
    BLAST report (-outfmt=1) will NOT contain GI information of the hit
    name. On the contary, the XML format report (-outfmt=5) still contains
    the GI information. So it recommended to output XML reports while
    doing BLAST analysis.

=head2 Input

=over

=item 1. A BLASTXML report.

=item 2. A SQLite3 database file.

=back

=head2 Operations:

=over

=item 1. Parse BLAST XML format report, get the these fileds:

		Query:

			- query_name
			- query_id
			- query_description
			- query_length

		Top hit:

			- GI
			- Accession number
			- Description
			- hit_length
			- evalue
			- score
			- iden%					# frac_identical
			- conv%					# frac_conserved
			- alignment length		# HSP length

=item 2. Query 'acc4tax.db' SQLite3 database, to get related tax_id.

=item 3. Query 'taxon.db' SQLite3 database, to get related taxonomy tree,
         from I<strain>, up to I<Root>.

=back

=head2 Output:

=over

=item 1. Tabular BLAST report (Converted by other scripts)

=item 2. Hirachy of taxonomy tree for each best hit for a query sequence,
         from I<strain> to I<Root>.

=back

=head1 AUTHOR

    zeroliu-at-gmail-dot-com

=head1 VERSION

    0.0.1   2014-06-27
    0.0.2   2014-06-30  Fix bugs.
                        Output data into an SQLite3 database.
    0.1.0   2014-08-05  Rename from 'parse_tax4blast.pl' to
                        'load_blast_tax2db.pl'.
    0.1.1   2014-08-26  improve import speed.
	0.2.0	2015-12-29	Renamed to 'load_blast2db.pl', which derived from
						'454_pipeline/load_blast_tax2db+WangJ.pl', for
						general purpose usage.
	0.2.1	2016-01-18	Bug fix.
    0.2.2   2016-01-22  Bug fix. Deprecated tax_id.
    0.2.3   2016-02-29  Bug fix. Unknown GI.
                        This usually caused by modification of GenBank
                        entries.
    0.3.0   2016-12-12  Use Accession.Version to replace GI Number.

=cut
# }}}

use 5.010;
use strict;
use warnings;

use autodie;
use Bio::SearchIO;
use DBI;
use File::Basename;
use List::MoreUtils qw(uniq);
use Switch;

use Smart::Comments;

#=====================================================================
#
# Global Environment
#
# !!! Modify the database PATH before use !!!
#
# These 2 databases must be generated by
#
# - "taxonomy/load_gi4tax.pl"
# - "taxonomy/load_taxon.pl"
#
#=====================================================================

my $db_acc4tax  = '/data/db/taxon/acc4tax.db';
my $db_taxon    = '/data/db/taxon/taxon.db';

die "[FATAL] Local NCBI taxonomy database NOT found"
    unless (-e $db_acc4tax && -e $db_taxon);

#=====================================================================

my $usage = << "EOS";
Load top hit details from a BLAST XML report and parse its taxonomy
information to an SQLite3 database.
Usage:
  load_blast_tax2db.pl <blast report> <db>
Arguments:
  <blast report>    A BLAST XML report.
  <db>              An SQLite3 database to store taxonomy information.
Note:
  - Only accept XML format BLAST report.
  - Verify the location of *acc4tax.db* and *taxon.db* before use.
EOS

my $frpt    = shift or die $usage;  # Input BLASTXML report
my $fdb     = shift or die $usage;  # Output SQLite database

my $blastprg;   # BLAST program, parsed from BLAST report

# my %rpt;    # Hash to store all report
# my %gis;    # hash to store gis, since there maybe multiple query ids
            # share one gi

# my %tax_info;     #hash to store taxid, maybe many gi to taxid
# my %uniq_taxids;    #hash to store uniq taxid.

my $num_hit_seq     = 0; # Number of query seuqences with hit(s)
my $num_total_seq   = 0; # Number of total query sequences

#=====================================================================
#
# Open BLAST XML report
#
#=====================================================================

my $o_rpti; # A Bio::SearchIO object

eval {
	$o_rpti  = Bio::SearchIO->new(
	    -file   => $frpt,
	    -format => 'blastxml',
	);
};

if ($@) {
    die "[ERROR] Open BLAST XML file '$frpt' failed!\n$@\n";
}

#=====================================================================
#
# Connect to database and enable bulk insert
#
#=====================================================================

# my $dbh	= conn_db($fdb);
our $dbh    = conn_db($fdb);

die "[ERROR] Connect to database '$fdb' failed!"
	unless (defined $dbh);

die "[ERROR] Setupt PRAGMA failed!\n"
	unless ( en_db_bulk_ins($dbh) );

#
# Insert basic information of analysis into table 'analysis'
#
my $anlys_id;   #    = ins_table_analysis();

# For each analysis, the analysis information would be inserted ONCE
my $F_anlys_id_inserted = 0;

#=====================================================================
#
# Parse BLAST report,
#
# - INSERT basic analysis information into table 'analysis'
# - INSERT result details into table 'result'
#
#=====================================================================

while (my $o_result = $o_rpti->next_result) {
    $blastprg   = $o_result->algorithm; # BLAST program

    # Insert basci inforamtion into table 'analysis'
    unless ( $F_anlys_id_inserted ) {
        $anlys_id   = ins_tbl_analysis( $blastprg);

        ### $anlys_id

        die "[ERROR] Insert table 'analysis' failed!\n"
            unless (defined $anlys_id);

        $F_anlys_id_inserted    = 1;
    }

    $num_total_seq++;

    # Dismiss query w/o hit
    my $num_hits    = $o_result->num_hits;
    next if ( $num_hits == 0 );
    $num_hit_seq++;

    # Parse result, and hit
    my $rh_rslt = parse_result($o_result);

    ## $rh_rslt

    ins_tbl_result($anlys_id, $rh_rslt) || die "<== 1\n";
}

say "Number of total sequences:\t",$num_total_seq;
say "Number of sequences with hits:\t", $num_hit_seq;
say "\n", "=" x 60, "\n";

upd_tbl_analysis($anlys_id, $num_total_seq, $num_hit_seq) || die "<== 2\n";

say "Parse blastxml report finished!\n";
#say "Next step translate gi to taxid!";

say "Next step translate Accession Number to taxonomy ID!";

say "\n", '=' x 60, "\n";

#
# Query table 'analysis' to get all GIs
#
#my $ra_gis  = query_uniq_gis() || die "<== 3";

#
# Query table 'analysis' to get all unique Accession Numbers
#
my $ra_accs  = query_uniq_accs() || die "<== 3";

#=====================================================================
#
# Query 'acc4tax.db' to get related tax_id for each gi.
# Then update table 'result'
#
#=====================================================================

#my $rh_gi_taxid = query_gi4tax( $ra_gis );

my $rh_acc_taxid = query_acc4tax( $ra_accs );

#upd_tbl_result($rh_gi_taxid) || die "<== 4\n";

upd_tbl_result($rh_acc_taxid) || die "<== 4\n";

say "\nParse taxonomy ID for Accession Number finished!\n";

say	"Next step: Get taxnomy details according to taxid.";

say "\n", '=' x 60, "\n";

my @uniq_taxids = uniq( values %{ $rh_acc_taxid } );

my $rh_taxinfo  = query_taxon( \@uniq_taxids );

# Insert taxonomy information into table 'taxon'
ins_tbl_taxon( $rh_taxinfo ) || die "<== 5\n";

say "[SUCCESS] All data loaded!";

$dbh->disconnect;

exit 0;

#=====================================================================
#
#                             Subroutines
#
#=====================================================================

=pod
  Name: conn_db($fdb)
  Desc: Connect to an SQLite3 database
  Args: $fdb    - SQLite3 database file
  Ret:  A database handle object
        undef   - All errors.
=cut

sub conn_db {
    my ($fdb)   = @_;

    my $dbh;

	eval {
	    $dbh = DBI->connect(
	        "dbi:SQLite:dbname=$fdb",
	        "", "",
	        {
	            RaiseError  => 1,
	            PrintError  => 1,
	            AutoCommit  => 1,
	        }
	    );
	};

    if ($@) {
        warn "[ERROR] Connect to database '$fdb' failed!\n$@\n";
        return;
    }

    return $dbh;
}

#===========================================================

=pod
  Name: en_db_bulk_ins($dbh)
  Desc: Enable bulk insert for SQLite3 database
  Args: $dbh    - Database handle object
  Ret:  None
        undef   - All errors.
=cut

sub en_db_bulk_ins {
    my ($dbh)   = @_;

    return unless (defined $dbh);

    eval {
        $dbh->do("PRAGMA synchronous = OFF");
        $dbh->do("PRAGMA cache_size  = 500000");    # Cache siez 500M
    };

    if ($@) {
        warn "[ERROR] Setup PRAGMA error:\n",
            $@, "\n";

        return;
    }

    return 1;
}


#===========================================================

=pod
  Name: parse_result($result)
  Desc: Parse BLAST result
  Args: A Bio::Search::Result::ResultI object
  Ret:  A reference of hash
        undef   - Any errors
=cut

sub parse_result {
    my ($o_result)  = @_;

    my %rslt;

    #
    # Parse query information
    #

	# In XML report, the query name is like 'Query_NNN'
    # i.e., the '<BlastOutput_query>' field
    # So we need to parse the query id (FASTA id) from the description
    # i.e., the '<BlastOutput_query-def>' field
    $rslt{'qry_name'}    = $o_result->query_name // "";
    $rslt{'qry_desc'}    = $o_result->query_description // "";

    if ($rslt{'qry_desc'}   =~ /^(.+?)\s/) {
        $rslt{'qry_id'} = $1;
    }
    else {
        warn "[WARN] Unidentified QUERY sequence description:\t
                '$rslt{'qry_desc'}'\n";

        $rslt{'qry_id'} = $rslt{'qry_desc'};    # Use description as ID
    }

    $rslt{'qry_len'}    = $o_result->query_length;

    #
    # Parse TOP hit information
    #

    my $o_hit   = $o_result->next_hit;

    # i.e., "<hit_id>...</hit_id>" element in BLASTXML report
    $rslt{'hit_name'}   = $o_hit->name;
    # In case there were NO GI Number in the "hit_id" element, return 0
    $rslt{'hit_gi'}     = parse_hit_gi( $rslt{'hit_name'} ) // 0;

    $rslt{'hit_acc'}    = $o_hit->accession;
    $rslt{'hit_desc'}   = $o_hit->description;
    $rslt{'hit_len'}    = $o_hit->length;
    $rslt{'eval'}       = $o_hit->significance;
    $rslt{'score'}      = $o_hit->bits;

    my $o_hsp   = $o_hit->next_hsp;

    $rslt{'iden'}       = sprintf("%.4f", $o_hsp->frac_identical);
    $rslt{'conv'}       = sprintf("%.4f", $o_hsp->frac_conserved);
    $rslt{'hsp_len'}    = $o_hsp->length('total');

    return \%rslt;
}

#===========================================================

=pod
  Name:	parse_hit_gi( $hit_name )
  Desc:	Parse gi number from hit name
        Now (2016-12), in NCBI web BLAST, the "Hit_id" format could be:
            gi|9630313|ref|NP_056790.1|
            gi|971888267|gb|ALV83303.1|
            gi|75051596|sp|Q9TTC1.1|POL_KORV
            gi|5726238|gb|AAD48375.1|AF123881_1
            gi|34392233|emb|CAD92796.1|
            gi|1048347874|pdb|5DMQ|A
  Args:	$hit_name
  Ret:	An integer.
=cut

sub parse_hit_gi {
	my ( $hit_name )	= @_;

	my $gi;

    if ($hit_name =~ /^gi\|(\d+)\|/) {
        $gi	= $1;
    }
    else {
        warn "[WARNING] Unidentified HIT sequence name:\t'$hit_name'\n";

		$gi	= "";
	}

	return $gi;
}

#===========================================================

=pod
  Name: ins_tbl_analysis($blast, $date)
  Desc: Insert basic informations into "analysis" table
  Args: $blast  - BLAST program
        $date   - Analysis date.
                  Default 'now'.
  Ret:  An integer  - Inserted row ID
        undef   - Any errors
=cut

sub ins_tbl_analysis {
    my ($blast, $date)  = @_;

    return unless (defined $blast);

    unless ( defined $date ) {
        my($day, $month, $year)=(localtime)[3,4,5];
        $date = ($year + 1900) . '-' . ($month + 1) . '-' . $day;
    }

    my $sql = << "EOS";
INSERT INTO analysis (
    blastprg,
    anlys_date
)
VALUES (
    ?, ?
);
EOS

    eval {
        $dbh->begin_work;

        my $sth = $dbh->prepare( $sql );

        $sth->bind_param(1, $blast);
        $sth->bind_param(2, $date);

        $sth->execute;

        $dbh->commit;
    };

    if ($@) {
        warn "[ERROR] Insert into table 'analysis' failed!\n",
                $@, "\n";

        $dbh->rollback;

        return;
    }

    return  $dbh->last_insert_id("", "", "analysis", "");
}

#===========================================================

=pod
  Name: upd_tbl_analysis($anlys_id, $total, $hit)
  Desc: Update table 'anlaysis'
  Args: $anlys_id   - Analysis id
        $total      - Total seq
        $hit        - Hit seq
  Ret:  None
        undef       - Any errors
=cut

sub upd_tbl_analysis {
    my ($anlys_id, $total, $hit)    = @_;

    my $sql = << "EOS";
UPDATE
    analysis
SET
    total_seq   = ?,
    hit_seq     = ?
WHERE
    id          = ?;
EOS

    eval {
        $dbh->begin_work;

        my $sth = $dbh->prepare($sql);

        $sth->bind_param(1, $total);
        $sth->bind_param(2, $hit);
        $sth->bind_param(3, $anlys_id);

        $sth->execute;

        $dbh->commit;
    };

    if ($@) {
        warn "[ERROR] Update table 'anlaysis' failed!\n",
            $@, "\n";

        $dbh->rollback;

        return;
    }

    return 1;
}

#===========================================================

=pod
  Name: ins_tbl_result($anlys_id, $rh_result)
  Desc: Insert information into table 'result'
  Args: $anlys_id   - Analysis ID, xref to table 'analysis'
        $rh_result  - A reference of hash, result details
  Ret:  None
        undef       - Any errors
=cut

sub ins_tbl_result {
    my ($anlys_id, $rh_rslt)  = @_;

    my $sql = << "EOS";
INSERT INTO result (
    anlys_id,
    qry_name,
    qry_id,
    qry_desc,
    qry_len,
    hit_name,
    hit_gi,
    hit_tax_id,
    hit_acc,
    hit_desc,
    hit_len,
    evalue,
    score,
    iden,
    conv,
    hsp_len
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
);
EOS

    eval {
        my $sth = $dbh->prepare($sql);

        $dbh->begin_work;

        $sth->bind_param( 1, $anlys_id);
        $sth->bind_param( 2, $rh_rslt->{'qry_name'});
        $sth->bind_param( 3, $rh_rslt->{'qry_id'});
        $sth->bind_param( 4, $rh_rslt->{'qry_desc'});
        $sth->bind_param( 5, $rh_rslt->{'qry_len'});
        $sth->bind_param( 6, $rh_rslt->{'hit_name'});
        $sth->bind_param( 7, $rh_rslt->{'hit_gi'});
        $sth->bind_param( 8, "");   # tax_id, vaule "" now
        $sth->bind_param( 9, $rh_rslt->{'hit_acc'});
        $sth->bind_param(10, $rh_rslt->{'hit_desc'});
        $sth->bind_param(11, $rh_rslt->{'hit_len'});
        $sth->bind_param(12, $rh_rslt->{'eval'});
        $sth->bind_param(13, $rh_rslt->{'score'});
        $sth->bind_param(14, $rh_rslt->{'iden'});
        $sth->bind_param(15, $rh_rslt->{'conv'});
        $sth->bind_param(16, $rh_rslt->{'hsp_len'});

        $sth->execute;

        $dbh->commit;
    };

    if ($@) {
        $dbh->rollback;

        warn "[ERROR] Insert into table 'result' failed!\n",
            $@, "\n";

        # If encounted errors, show debug information
        ## $rh_rslt

        return;
    }

    return 1;
}

#===========================================================

=pod
  Name: upd_tbl_result($rh_gi_tax)
  Desc: Update table 'result' with tax_id
  Args: A reference of hash
  Ret:  None
        undef   - Any errors
=cut

sub upd_tbl_result {
    # For GI Number Version
    # my ($rh_gi_tax) = @_;

    my ($rh_acc_tax)    = @_;

    ## For debug
    my $tax_id  = 0;
    my $acc     = 0;

=pod For GI Number Version
    my $sql = << "EOS";
UPDATE
    result
SET
    hit_tax_id  = ?
WHERE
    hit_gi      = ?;
EOS
=cut

    # For Accession Number Version
    my $sql = << "EOS";
UPDATE
    result
SET
    hit_tax_id  = ?
WHERE
    hit_acc     = ?;
EOS

    eval {
        $dbh->begin_work;

        my $sth = $dbh->prepare($sql);

        for $acc (keys %{$rh_acc_tax} ) {
            $tax_id = $rh_acc_tax->{ $acc };

            ## $tax_id
            ## $gi

            # $sth->bind_param(1, $rh_gi_tax->{$gi});
            $sth->bind_param(1, $tax_id);
            $sth->bind_param(2, $acc);

            $sth->execute;
        }

        $dbh->commit;
    };

    if ($@) {
        $dbh->rollback;

        warn "[ERROR] On GI '$acc' and tax ID '$tax_id': \n",
            "Update table 'result' failed!\n",
            $@, "\n";

        return;
    }

    return 1;
}

#===========================================================

=pod
  Name: query_uniq_gis()
  Desc: Query table 'analysis' to get unique GIs
  Args: None
  Ret:  A reference of array
        undef   - Any errors
=cut

sub query_uniq_gis{
    my $sql = << "EOS";
SELECT
    DISTINCT hit_acc
FROM
    result
EOS

    my $sth;

    eval {
        $sth = $dbh->prepare($sql);
        $sth->execute;
    };

    if ($@) {
        warn "[ERROR] Query table 'analysis' for 'hit_acc' failed!\n",
            $@, "\n";

        return;
    }

    my @accs;

    while (my $rh_row = $sth->fetchrow_hashref) {
        push @accs, $rh_row->{'hit_acc'};
    }

    return \@accs;
}

#===========================================================

=pod
  Name: query_uniq_accs()
  Desc: Query table 'analysis' to get unique Accesion Numbers
  Args: None
  Ret:  A reference of array
        undef   - Any errors
=cut

sub query_uniq_accs{
    my $sql = << "EOS";
SELECT
    DISTINCT hit_acc
FROM
    result
EOS

    my $sth;

    eval {
        $sth = $dbh->prepare($sql);
        $sth->execute;
    };

    if ($@) {
        warn "[ERROR] Query table 'analysis' for 'hit_gi' failed!\n",
            $@, "\n";

        return;
    }

    my @accs;

    while (my $rh_row = $sth->fetchrow_hashref) {
        push @accs, $rh_row->{'hit_acc'};
    }

    return \@accs;
}

#===========================================================

=pod
  Name: query_gi4tax($ra_gis)
  Desc: Query database 'acc4tax.db' to get tax_id
  Args: $ra_gis - A reference of array
  Ret:  A reference of hash
        undef   - Any errors
=cut

sub query_gi4tax {
    my ($ra_gis)    = @_;

    #
    # Connect to database 'gi4tax'
    #

    my $dbh = conn_db($db_acc4tax);

    my $sql = << "EOS";
SELECT
    tax_id
FROM
    gi4tax
WHERE
    gi  = ?
EOS

    my $sth;

    eval {
        $sth = $dbh->prepare($sql);
    };

    if ($@) {
        warn "[ERROR] Prepare query '$sql' failed!\n",
            $@, "\n";

        return;
    }

    my %gi_tax;

    eval {
        for my $gi ( @{$ra_gis} ) {
            $sth->bind_param(1, $gi);
            $sth->execute;

            my $rh_row  = $sth->fetchrow_hashref;

            unless (defined $rh_row) {
                warn "[ERROR] NO entry for GI '$gi'!\n";
                next;
            }

            $gi_tax{ $gi }  = $rh_row->{'tax_id'};

            if ($rh_row = $sth->fetchrow_hashref) {
                warn "[ERROR] Multi taxon entries for GI '$gi'\n";
                $sth->finish;
            }
        }
    };

    if ($@) {
        warn "[ERROR] Query 'gi' for table 'gi4tax' failed!\n",
            $@, "\n";


        return;
    }


    $dbh->disconnect;

    ## %gi_tax

    return \%gi_tax;
}

#===========================================================

=pod
  Name: query_acc4tax($ra_accs)
  Desc: Query database 'acc4tax.db' to get tax_id
  Args: $ra_accs - A reference of array
  Ret:  A reference of hash
        undef   - Any errors
=cut

sub query_acc4tax {
    my ($ra_accs)    = @_;

    #
    # Connect to database 'acc4tax'
    #

    my $dbh = conn_db($db_acc4tax);

    my $sql = << "EOS";
SELECT
    tax_id
FROM
    acc4tax
WHERE
    acc = ?
EOS

    my $sth;

    eval {
        $sth = $dbh->prepare($sql);
    };

    if ($@) {
        warn "[ERROR] Prepare query '$sql' failed!\n",
            $@, "\n";

        return;
    }

    my %acc_tax;

    eval {
        for my $acc ( @{$ra_accs} ) {
            $sth->bind_param(1, $acc);
            $sth->execute;

            my $rh_row  = $sth->fetchrow_hashref;

            unless (defined $rh_row) {
                warn "[ERROR] NO entry for Accessoion Number '$acc'!\n";
                next;
            }

            $acc_tax{ $acc }  = $rh_row->{'tax_id'};

            if ($rh_row = $sth->fetchrow_hashref) {
                warn "[ERROR] Multi taxon entries for GI '$acc'\n";
                $sth->finish;
            }
        }
    };

    if ($@) {
        warn "[ERROR] Query 'hit_acc' for table 'acc4tax' failed!\n",
            $@, "\n";


        return;
    }


    $dbh->disconnect;

    ## %acc_tax

    return \%acc_tax;
}

#===========================================================

=pod
  Name: query_taxon($ra_taxids)
  Desc: Query database 'taxon.db' with tax_ids
  Args: A reference of array
  Ret:  A reference of hash for taxon details
        undef   - Any errors
=cut

sub query_taxon {
    my ($ra_taxids) = @_;

    my $dbh = conn_db( $db_taxon );

    my $sql = << "EOS";
SELECT nd.tax_id AS tax_id,
       nd.parent_tax_id AS parent_tax_id,
       nd.rank AS rank,
       nm.name AS name,
       dv.name AS division
  FROM nodes AS nd,
       names AS nm,
       division AS dv
 WHERE nd.tax_id = ?
       AND
       nd.tax_id = nm.tax_id
       AND
       nd.div_id = dv.div_id
       AND
       nm.class = 'scientific name';
EOS

    my $sth;

    # Run "prepare" OUTSIDE the cycle.
    eval {
        $sth    = $dbh->prepare($sql);
    };

    if ($@) {
        warn "[ERROR] Prepare query '$sql' failed!\n",
            $@, "\n";

        return;
    }

    # Store details of all tax_id
    my %tax_info;

    for my $tax_id ( @{ $ra_taxids } ) {
	    # In case there were any tax_id unknown
	    # This happens when a nucleotide or protein sequences were removed
	    # from the GenBank database
        unless (defined $tax_id) {
            warn "[ERROR] Unknow tax_id '$tax_id'\n" ;
            next;
        }

	    my ($parent_tax_id, $rank, $name, $division);

	    $parent_tax_id = 0; # Just to restrain the 'uninitialized' warning
	                        # There is NO tax_id = 0,
	                        # For Root, its tax_id = 1.

	    # Loop UNTIL parent is ROOT (of which tax_id = 1)
	    my $cur_tax_id  = $tax_id;

	    while ( $parent_tax_id != 1) {
	        # my $ra_ret = query_tax_info($cur_tax_id, $dbh, $sth);

	        # ($parent_tax_id, $rank, $name, $division) = @{ $ra_ret };

            ($parent_tax_id, $rank, $name, $division)
                = query_tax_info($cur_tax_id, $dbh, $sth);

	        ## tax id:         $tax_id
	        ## parent tax id:  $parent_tax_id
	        ## rank:           $rank
	        ## name:           $name
	        ## division:       $division

            # If there were NO related information, i.e., the query
            # tax_id was deprecated
	        unless (defined $parent_tax_id && defined $rank
                        && defined $name && defined $division) {
                say "==> Un-identified tax id:\t", $tax_id;
                last;
            }

	        $tax_info{$tax_id}->{$rank}      = $name;

	 	    $tax_info{$tax_id}->{'division'} = $division;

	        # Generate taxonomy hierarchy tree
	        # Hierarchy rank

	        if (defined $tax_info{$tax_id}->{'hier'}) {
	            $tax_info{$tax_id}->{'hier'}
	                = $rank . '; ' . $tax_info{$tax_id}->{'hier'};
	        }
	        else {
	            $tax_info{$tax_id}->{'hier'} = $rank;
	        }

	        # Hierarchy rank name

	        if (defined $tax_info{$tax_id}->{'hier_name'}) {
	            $tax_info{$tax_id}->{'hier_name'}
	                = $name . '; ' . $tax_info{$tax_id}->{'hier_name'};
	        }
	        else {
	            $tax_info{$tax_id}->{'hier_name'} = $name;
	        }

	        $cur_tax_id = $parent_tax_id;
        }
    }
    $dbh->disconnect;

    return \%tax_info;
}

=pod
  Name: query_tax_info
  Desc: query_tax_info( $tax_id, $dbh, $sth)
  Func: Query taxon SQLite3 database on table 'nodes', 'names' and
        'division', to retrieve related information
  Args: $tax_id     A NCBI taxonomy id
  Ret:  A reference of an array
=cut

sub query_tax_info {
    my ($tax_id, $dbh, $sth) = @_;

    my ($parent_tax_id, $rank, $name, $division);

    eval {
        $sth->bind_param(1, $tax_id);

        $sth->execute;

        my $rh_row = $sth->fetchrow_hashref;

        $parent_tax_id   = $rh_row->{'parent_tax_id'};
        $rank            = $rh_row->{'rank'};
        $name            = $rh_row->{'name'};
        $division        = $rh_row->{'division'};

        if ($rh_row = $sth->fetchrow_hashref) {
            warn "[ERROR] Multi entries for taxon '$tax_id'.";

            $sth->finish;
        }
    };

    if ($@) {
        warn "[ERROR] Query '$tax_id' failed!\n", $@, "\n";

        return;
    }

    my @ret = ($parent_tax_id, $rank, $name, $division);

    return @ret;
}

#===========================================================

=pod
  Name: ins_tbl_taxon( $rh_taxinfo )
  Desc: Insert taxonomy details into table 'taxon'
  Args: A reference of hash
  Ret:  None
        undef for any errors
=cut

sub ins_tbl_taxon {
    my ($rh_taxinfo)    = @_;

    my $sql = << "EOS";
INSERT INTO taxon (
    tax_id,
    tax_hier,
    tax_hier_name,
    hit_superkingdom,
    hit_kingdom,
    hit_phylum,
    hit_class,
    hit_order,
    hit_family,
    hit_genus,
    hit_species,
    hit_division
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
);
EOS

    my $sth;

    eval {
        $sth    = $dbh->prepare( $sql );
    };

    if ($@) {
        warn "[ERROR] Prepare SQL statement '$sql' failed!\n",
            $@, "\n";

        return;
    }

    eval {
        $dbh->begin_work;

        for my $tax_id ( sort keys %{ $rh_taxinfo } ) {
            my $tax_hier
                    = $rh_taxinfo->{$tax_id}->{'hier'} // '';

            my $tax_hier_name
                    = $rh_taxinfo->{$tax_id}->{'hier_name'} // '';

            my $hit_superkingdom
                    = $rh_taxinfo->{$tax_id}->{'superkingdom'} // '';

            my $hit_kingdom
                    = $rh_taxinfo->{$tax_id}->{'superkingdom'} // '';

            my $hit_phylum
                    = $rh_taxinfo->{$tax_id}->{'phylum'} // '';

            my $hit_class
                    = $rh_taxinfo->{$tax_id}->{'class'} // '';

            my $hit_order
                    = $rh_taxinfo->{$tax_id}->{'order'} // '';

            my $hit_family
                    = $rh_taxinfo->{$tax_id}->{'family'} // '';

            my $hit_genus
                    = $rh_taxinfo->{$tax_id}->{'genus'} // '';

            my $hit_species
                    = $rh_taxinfo->{$tax_id}->{'species'} // '';

            my $hit_division
                    =  $rh_taxinfo->{$tax_id}->{'division'} // '';

            $sth->bind_param( 1, $tax_id);
            $sth->bind_param( 2, $tax_hier);
            $sth->bind_param( 3, $tax_hier_name);
            $sth->bind_param( 4, $hit_superkingdom);
            $sth->bind_param( 5, $hit_kingdom);
            $sth->bind_param( 6, $hit_phylum);
            $sth->bind_param( 7, $hit_class);
            $sth->bind_param( 8, $hit_order);
            $sth->bind_param( 9, $hit_family);
            $sth->bind_param(10, $hit_genus);
            $sth->bind_param(11, $hit_species);
            $sth->bind_param(12, $hit_division);

            $sth->execute;
        }

        $dbh->commit;
    };

    if ($@) {
        $dbh->rollback;

        warn "[ERROR] Insert into table 'taxon' failed!\n",
            $@, "\n";

        return;
    }

    return 1;
}
